package exploit;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import javax.xml.bind.annotation.XmlAttribute;

import systemModel.Asset;
import systemModel.Capability;
import systemModel.CommunicationMedium;
import systemModel.Exploitable;
import systemModel.Software;
import types.Resources;
import attackerProfile.Access;
import attackerProfile.AttackerProfile;
import attackerProfile.Skill;


/**
 * An exploit represents a potential action against an exploitable to disrupt its
 * availability or to gain control over it or against an attractor to exploit its
 * value.
 * @author Martin Salfer
 * @version 1.0
 * @created 12-Nov-2013 16:18:08
 */
public abstract class Exploit {

	/**
	 * Traverse a ComNode, which is neutral and therefore takes zero resource effort. 
	 */
	public static final Exploit COM_MEDIUM_TRAVERSAL_EXPLOIT = new PotentialExploit("Communication Medium Traversal", null, new Resources(0d,0d));
	
	/**
	 * Can this exploit brick the ECU?
	 * 
	 * For example the TPMS ECU was bricked by Rouf et al.
	 */
	private final boolean bricksECU;
	private final boolean disruptsAvailability;
	protected final String name;
	private final boolean takesOverControl;
	protected final Set<Exploitable> targets = new HashSet<Exploitable>();
	protected final Set<CommunicationMedium> exploitationMedium = new HashSet<CommunicationMedium>();
	private final Set<Capability> necessaryCapabilities = new HashSet<Capability>();
	/**
	 * Required skills for successfully mounting an attack. The proficiency factor is normalised as "1" for average person.
	 */
	protected final Map<Skill, Float> requiredSkills = new HashMap<Skill, Float>();
	/**
	 * Resources necessary to adapt a known PoC exploit to a concrete target vulnerability.
	 */
	protected final Resources adaptionEffort;

	protected final Resources creationEffort;

	public Exploit() {
		this("<unnamed>", null);
	}
	
	public Exploit(String name, Exploitable target) {
		this(name, target, false, false, false, new Resources(100d,0d), new Resources(100d,0d));
	}

	public Exploit(String name, Exploitable target, boolean dosAble, boolean controlAble, boolean brickAble, Resources creationEffort, Resources adaptionEffort) {
		targets.add(target);
		this.name = name;
		disruptsAvailability = dosAble;
		takesOverControl = controlAble;
		bricksECU = brickAble;
		this.creationEffort = creationEffort;
		this.adaptionEffort = adaptionEffort;
	}

	@Override
	public String toString() {
		return "Exploit [" + name + "]"; // + takesOverControl + disruptsAvailability + bricksECU;
	}
	
	@XmlAttribute
	public String getName() {
		return name;
	}
	
	public void finalize() throws Throwable {

	}


	/**
	 * Complexity: O(1) as of 6.
	 * @param task
	 * @return
	 */
	public boolean isApplicableAgainstSw(Exploitable task) {
		return targets.contains(task);
	}

	/**
	 * Complexity: O(1) as of 7.
	 * @param availableCaps
	 * @return
	 */
	public boolean isApplicableWithCapabilities(Set<Capability> availableCaps) {
		return availableCaps.containsAll(necessaryCapabilities); // Complexity: O(1) as of 7.
	}
	
	/**
	 * Complexity: O(1) as of 1,2,3,4,6,7,8.
	 * @param origin
	 * @param target
	 * @return
	 */
	public boolean areSwCapComConditionsMet(Software origin, Exploitable target) {
		return isApplicableAgainstSw(target) && // Complexity: O(1) as of 6.
				isApplicableWithCapabilities(origin.getCapabilities()) && // Complexity: O(1) as of 7
				isApplicableOverComNode(origin, target); // Complexity: O(1) as of 1,2,3,4,8
	}

	/**
	 * Complexity: O(1) as of 1,2,3,4,8
	 * @param origin
	 * @param target
	 * @return
	 */
	private boolean isApplicableOverComNode(Software origin, Exploitable target) {
		Set<CommunicationMedium> comNodes = target.getComNodesWith(origin); // Having target first allows polymorphism. // Complexity: O(1) as of 1,2,3,4.
		if (exploitationMedium.size() == 0)
			return true; // special case: an exploit that requires no specific com node is treated as universally applicable.
		for (CommunicationMedium n : comNodes) { // Complexity: O(1) as of 1,2,3,4 (presumably)
			if (isApplicableViaComNode(n)) // Complexity: O(1) as of 8
				return true;
		}
		return false; 
	}

	/**
	 * The costs for exploit application for a certain attacker.
	 * 
	 * Depending on skills of an attacker and the requirements of the exploit.
	 * Skills and reqs are weightened.
	 * @param attacker
	 * @return Necessary resources.
	 */
	public Resources costsForAttacker(AttackerProfile attacker) {
		Resources cost = new Resources(creationEffort).addWith(adaptionEffort);
		if (!requiredSkills.isEmpty()) { // for speed improvement to not execute keySet() unnecessarily.
			for (Skill s : requiredSkills.keySet()) {
				// for all required skills. Multiply all skills and how those are necessary. Standard value is 1 (average person)
				cost = cost.multiplyWith(getRecommendedSkillProficiency(s) / attacker.availableProficiencyForSkill(s));
			}
		}
		return cost;
	}

	public void setRecommendedSkillProficiency(Skill skill, float proficiency) {
		requiredSkills.put(skill, proficiency);
	}
	
	protected float getRecommendedSkillProficiency(Skill s) {
		return requiredSkills.get(s);
	}

	/**
	 * Complexity: O(1) ? as of ?
	 * @param comNode
	 * @return
	 */
	public boolean areSwCapComConditionsMet(CommunicationMedium comNode, Exploitable target) {
		return isApplicableAgainstSw(target) && // Complexity: O(1) as of 6.
				isApplicableViaComNode(comNode); // Complexity: O(1) and ?as of 1,2,3,4,8
	}

	/**
	 * Is this Exploit applicable over Communication Node comNode?
	 * Complexity: O(1) as of 8.
	 * @param comNode The Communication Node an attack is anticipated to be applied.
	 * @return true if this comNode is listed as valid or no requirements are given.
	 */
	private boolean isApplicableViaComNode(CommunicationMedium comNode) {
		if (exploitationMedium.size() == 0) // Complexity: O(1).
			return true; // special case: an exploit that requires no specific com node is treated as universally applicable.
		return exploitationMedium.contains(comNode); // Complexity: O(1) as of 8.
	}
	
	
}//end Exploit